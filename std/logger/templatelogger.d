module std.logger.templatelogger;

public import std.logger.core;
import std.functional : unaryFun;
import std.string;
import std.format;
import std.array;
import std.range;

/** This function will create a log message in the default way used in the
$(D std.logger).
*/
public void defaultFormatter(T,F)(ref T t, ref F payload) @trusted
{
    size_t fnIdx = payload.file.lastIndexOf('/') + 1;
    size_t funIdx = payload.funcName.lastIndexOf('.') + 1;
    auto time = payload.timestamp.toISOExtString();
    formattedWrite(t, "%s:%s:%s:%u %s\n", time[0 .. 25],
        payload.file[fnIdx .. $], payload.funcName[funIdx .. $],
        payload.line, payload.msg);
}

/** The $(D TemplateLogger) is an easy way to build custom logger.

The $(D TemplateLogger) takes a Sink a Formatter and a Filter. The Filter
takes a $(D Logger.LoggerPayload) as a parameter and returns $(D true) if the
message is supposed to be logged. The Formatter takes an $(D OutputRange) and
a $(D Logger.LoggerPayload) as a parameter and processes it depending on its
implementation. The Sink will present the log message generated by the
Formatter.
*/
abstract class TemplateLogger(Sink, alias Formatter, alias Filter) : Logger
{
    private alias filterFun = unaryFun!Filter;

    /** A constructor for the TemplateLogger.

    Params:
        lv = The $(D LogLevel) used by the logger.
    */
    public this(const LogLevel lv = LogLevel.info)
    {
        this("", lv);
    }

    /** A constructor for the TemplateLogger.

    Params:
        name = The name of the $(D Logger).
        lv = The $(D LogLevel) used by the logger.
    */
    public this(string name, const LogLevel lv = LogLevel.info)
    {
        super(name, lv);
    }

    Sink getSink();
    void cleanup();

    public override void writeLogMsg(ref LoggerPayload payload)
    {
        version(DisableTemplateLogging)
        {
        }
        else
        {
            Sink sink = this.getSink();
            if (filterFun(payload))
            {
                Formatter(sink, payload);
                this.cleanup();
            }
        }
    }
}
